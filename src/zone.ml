open Batteries
open Common
module Ip6 = Ipset.Ip6
module Ip4 = Ipset.Ip4
module F = Frontend


(** Predefined zones. *)

(** The self zone is the machine it self. *)
let self = "self"

(** The martian zone. Networks packets that have no zone are declared
    martian, which is identified by this build in zone *)
let mars = "mars"

(** Reference to all zone chains. This build in rule traverses all
    zone rules *)
let all_zones = "zones"

(** List of build in zones. *)
let buildin_zones = [ mars ]

let rec filter_interface = function
  | F.Interface (name, _pos) :: xs -> name :: filter_interface xs
  | _ :: xs -> filter_interface xs
  | [] -> []

let rec filter_network = function
  | F.Network ip :: xs -> ip :: filter_network xs
  | _ :: xs -> filter_network xs
  | [] -> []

let rec filter_zonerules table = function
  | F.ZoneRules (t, r, p) :: xs when (fst t) = (fst table) -> (r, p) :: filter_zonerules table xs
  | _ :: xs -> filter_zonerules table xs
  | [] -> []

(** Return a chain that will mark the zone based on direction *)
let create_zone_chain direction (id, nodes) =
  let create_network_rules chain ips =
    let (ip4, ip6) =
      List.fold_left
        (fun (ip4, ip6) -> function
           | F.Ipv4 i -> ( i :: ip4, ip6)
           | F.Ipv6 i -> (ip4, i :: ip6)) ([], []) ips
    in
    [ ([(Ir.Ip6Set(direction, Ip6.of_list ip6), false)], Ir.Jump chain.Ir.id);
      ([(Ir.Ip4Set(direction, Ip4.of_list ip4), false)], Ir.Jump chain.Ir.id) ]

  in
  let create_interface_rule chain interface =
    ([(Ir.Interface(direction, Set.singleton interface), false)], Ir.Jump chain.Ir.id)
  in
  let chain = Chain.create [([], Ir.MarkZone(direction, id))] ("Mark zone " ^ id) in
  let network_nodes = filter_network nodes in
  let interface_nodes = filter_interface nodes in

  let chain =
    if List.length network_nodes > 0 then
      Chain.create (create_network_rules chain (filter_network nodes)) ("Match networks for zone " ^ id)
    else
      chain
  in
    if List.length interface_nodes > 0 then
      Chain.create (List.map (create_interface_rule chain) (filter_interface nodes)) ("Match interfaces for zone " ^ id)
    else
      chain

let rec filter = function
  | F.Zone(id, nodes) :: xs -> (id, nodes) :: filter xs
  | _ :: xs -> filter xs
  | [] -> []

(** Utility function to create an set of zone id's *)
let create_zone_set nodes =
  let rec traverse acc = function
    | F.Zone ((id, _pos), _) :: xs -> traverse (BatSet.add id acc) xs
    | _ :: xs -> traverse acc xs
    | [] -> acc
  in traverse (BatSet.of_list buildin_zones) nodes

(** Emit autogenerated nodes to be inserted in the stream of frontent nodes. *)
let emit_nodes table zones =
  let gen_rule_stems (zone_id, nodes) =
    let zonerules = filter_zonerules table nodes in
    List.map (
      fun (rules, policy) ->
        F.Rule( F.Filter(("destination", Lexing.dummy_pos),
                         F.FZone([F.Id zone_id]), false) :: rules, policy )
    ) zonerules
  in
  let rules = List.flatten (List.map gen_rule_stems zones) in
  F.DefineStms ((all_zones, Lexing.dummy_pos), rules)

let emit_filter zones =
  let src_chains = List.map (create_zone_chain Ir.Direction.Source) zones in
  let dst_chains = List.map (create_zone_chain Ir.Direction.Destination) zones in
  let src_chain = Chain.create (([], Ir.MarkZone(Ir.Direction.Source, mars)) :: (List.map (fun chn -> ([], Ir.Jump chn.Ir.id)) src_chains)) "Mark source zones" in
  let dst_chain = Chain.create (([], Ir.MarkZone(Ir.Direction.Destination, mars)) :: (List.map (fun chn -> ([], Ir.Jump chn.Ir.id)) dst_chains)) "Mark destination zones" in
  let input_opers = [ [], Ir.MarkZone (Ir.Direction.Destination, self); [], Ir.Jump src_chain.Ir.id  ] in
  let output_opers = [ [], Ir.MarkZone (Ir.Direction.Source, self); [], Ir.Jump dst_chain.Ir.id ] in
  let forward_opers = [ [], Ir.Jump src_chain.Ir.id ; [], Ir.Jump dst_chain.Ir.id ] in
  (* Why dont I do this? *)
  (input_opers, output_opers, forward_opers)

let emit_nat (zones : (string * F.zone_stm list) list) : Ir.oper list =
  let gen (zone : string) = function
    | F.ZoneSnat (src_zones, ip) ->
        if (Ipaddr.V4.Prefix.bits ip < 32) then (parse_error "Snat not not work with network ranges");
        ((Ir.Zone (Ir.Direction.Source, Rule.list2ids src_zones |> List.map fst |> Set.of_list), false) ::
         (Ir.Zone (Ir.Direction.Destination, zone |> Set.singleton), false) :: [],
                 Ir.Snat (Ipaddr.V4.Prefix.network ip)) |> Option.some
    | F.Interface _
    | F.Network _
    | F.ZoneRules _ -> None
  in

  List.map (fun (zone, stms) -> List.filter_map (gen zone) stms) zones
  |> List.flatten
