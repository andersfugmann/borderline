# Rules for all zones.
define common = {

    # Dhcp rules. Must apprear before dropping martian packets
    rule {
        use external_dhcp; #if

        # Dhcp ipv4.
        rule {
            # Requests to the DHCP server
            # The DHCP server will always use its ip address
            source zone = self;

            address family = ipv4;
            protocol = [ udp ];
            source udp port = bootpc;
            destination udp port = bootps;

            rule {
                 destination zone = external;
            } policy accept;
            rule {
                destination address = 255.255.255.255
            } policy accept;
        };

        rule {
            # Replies from the DHCP server
            # The DHCP server will always use its ip address
            destination zone = self;
            source zone = external;

            address family = ipv4;
            protocol = [ udp ];
            source udp port = bootps;
            destination udp port = bootpc;
        } policy log_allow;

        # Ipv6
        rule { # Solicit / Request / Renew
            # Initial request goes to ff02::1:2
            address family = ipv6;
            protocol = [ udp ];
            source udp port = dhcpv6-client;
            destination udp port = dhcpv6-server;

            # Solicit from ff02::1:
            # Request from link-local
            # Renew from assigned global ip
            # These will all be from the local server,
            source zone = self;

            rule { destination zone = external; } policy log_allow;
            rule { destination address = [ ff02::1:2, local ]; } policy log_allow;
        };
        rule {
            # Replies comes from the global ip address or link local
            address family = ipv6;
            protocol = [ udp ];
            destination udp port = dhcpv6-client;
            source udp port = dhcpv6-server;

            rule {
                 source zone = external;
                 rule { destination zone = self; } policy log_allow;
                 rule { destination address = [ local ]; } policy log_allow;
            };
            rule {
                 source address = local;
                 rule { destination zone = self; } policy log_allow;
                 rule { destination address = [ local ]; } policy log_allow;
            }
        };
    };

    rule {
        # Drop any martian packets. Martians defined as packets from unallocated networks
        rule { source zone = mars; } policy log_martian;
        rule { destination zone = mars; } policy log_martian;
    };
    rule { source zone = self; destination zone = self; } policy log_allow;
    rule { state = [ related, established ]; } policy log_allow;

    use validate;

    # For some reason, icmpv6 packets are not in connection tracking, so
    # they have ct state untracked
    rule {
        icmp6 = [ router-solicitation-6,
                  router-advertisement-6,
                  neighbor-solicitation-6,
                  neighbor-advertisement-6,
                  redirect-message-6,
                  indirect-neighbor-solicit-6,
                  inverse-neighbor-discovery-advertisement-message-6,
                  multicast-listener-discovery2-6,
                  multicast-listener-query-6,
                  multicast-listener-done-6,
                  multicast-listener-report-6,
                  multicast-router-advertisement-6,
                  multicast-router-termination-6,
                  multicast-router-solicitation-6 ];
    } policy log_allow;


    rule {
        state = new;

        rule { icmp4 = [ echo-request ] } policy log_allow;
        rule { icmp6 = [ echo-request-6 ] } policy log_allow;

        rule { destination tcp port = global_tcp_ports; } policy log_allow;
        rule { destination udp port = global_udp_ports; } policy log_allow;
        rule {
            destination zone = self;
            rule { destination tcp port = public_tcp_ports } policy log_allow;
            rule { destination udp port = public_udp_ports } policy log_allow;
        };
        rule {
            use allow_outbound; #if
            destination zone = external;
        } policy allow;

        # Dhcp server
        rule {
             # Requests
             rule {
                 address family = ipv4;
                 protocol = [ udp ];
                 source udp port = bootpc;
                 destination udp port = bootps;
                 source zone = dhcp_server_zones;
                 destination zone = self;
             } policy log_allow;
             # Replies
             rule {
                 address family = ipv4;
                 protocol = [ udp ];
                 source udp port = bootps;
                 destination udp port = bootpc;
                 destination zone = dhcp_server_zones;
                 source zone = self;
             } policy log_allow;
         };
    };
}
